/**
 * @module furi
 */
import assert from "assert";
import isWindows from "is-windows";
import url from "url";
/**
 * Normalizes the input to a frozen `URL` instance.
 *
 * @param input URL string or instance to normalize.
 */
export function asFuri(input) {
    if (typeof input === "string") {
        const writable = new url.URL(input);
        freezeUrl(writable);
        return writable;
    }
    else if (!Object.isFrozen(input)) {
        const writable = new url.URL(input.toString());
        freezeUrl(writable);
        return writable;
    }
    else {
        return input;
    }
}
/**
 * Normalizes the input to a writable `URL` instance.
 *
 * @param input URL string or instance to normalize.
 */
export function asWritableUrl(input) {
    return new url.URL(typeof input === "string" ? input : input.toString());
}
/**
 * Appends the provided components to the pathname of `base`.
 *
 * It does not mutate the inputs.
 * If component list is non-empty, the `hash` and `search` are set to the
 * empty string.
 *
 * @param base Base URL.
 * @param components Path components to append.
 * @returns Joined URL.
 */
export function join(base, components) {
    if (components.length === 0) {
        return asFuri(base);
    }
    const writable = asWritableUrl(base);
    const oldPathname = writable.pathname;
    const tail = components
        .map(encodeURIComponent)
        .join("/");
    writable.hash = "";
    writable.search = "";
    const separator = oldPathname.endsWith("/") ? "" : "/";
    writable.pathname = `${oldPathname}${separator}${tail}`;
    freezeUrl(writable);
    return writable;
}
/**
 * Returns the parent URL.
 *
 * If `input` is the root, it returns itself (saturation).
 * If `input` has a trailing separator, it is first removed.
 *
 * @param input Input URL.
 * @returns Parent URL.
 */
export function parent(input) {
    const writable = asWritableUrl(input);
    const oldPathname = writable.pathname;
    const components = oldPathname.split("/");
    if (components[components.length - 1] === "") {
        // Remove trailing separator
        components.pop();
    }
    components.pop();
    writable.pathname = components.join("/");
    freezeUrl(writable);
    return writable;
}
/**
 * Converts a File URI to a system-dependent path.
 *
 * Use `toPosixPath`, `toWindowsShortPath` or `toWindowsLongPath` if you
 * want system-independent results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file:///C:/dir/foo", true);
 * // -> "\\\\?\\C:\\dir\\foo";
 *
 * // On a Posix system:
 * toSysPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @param windowsLongPath Use long paths on Windows. (default: `false`)
 * @return System-dependent path.
 */
export function toSysPath(furi, windowsLongPath = false) {
    if (isWindows()) {
        return windowsLongPath ? toWindowsLongPath(furi) : toWindowsShortPath(furi);
    }
    else {
        return toPosixPath(furi);
    }
}
/**
 * Converts a File URI to a Windows short path.
 *
 * The result is either a short device path or a short UNC server path.
 *
 * Example:
 * ```js
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file://server/Users/foo");
 * // -> "\\\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows short path.
 */
export function toWindowsShortPath(furi) {
    const urlObj = new url.URL(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        return toBackwardSlashes(forward);
    }
    else {
        // Server path
        const pathname = new url.URL(furi).pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\${urlObj.host}${backward}`;
    }
}
/**
 * Converts a File URI to a Windows long path.
 *
 * The result is either a long device path or a long UNC server path.
 *
 * Example:
 * ```js
 * toWindowsPath("file:///C:/dir/foo");
 * // -> "\\\\?\\C:\\dir\\foo";
 * toWindowsPath("file://server/Users/foo");
 * // -> "\\\\?\\unc\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows long path.
 */
export function toWindowsLongPath(furi) {
    const urlObj = new url.URL(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\${backward}`;
    }
    else {
        // Server path
        const pathname = new url.URL(furi).pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\unc\\${urlObj.host}${backward}`;
    }
}
/**
 * Converts a File URI to a Posix path.
 *
 * Requires the host to be either an empty string or `"localhost"`.
 *
 * Example:
 * ```js
 * toPosixPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Posix path.
 */
export function toPosixPath(furi) {
    const urlObj = new url.URL(furi);
    if (urlObj.host !== "" && urlObj.host !== "localhost") {
        assert.fail(`Expected \`host\` to be "" or "localhost": ${furi}`);
    }
    const pathname = urlObj.pathname;
    return pathname.split("/").map(decodeURIComponent).join("/");
}
/**
 * Converts an absolute system-dependent path to a frozen URL object.
 *
 * Use `fromPosixPath` or `fromWindowsPath` if you want system-independent
 * results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * fromSysPath("C:\\dir\\foo");
 * // -> new URL("file:///C:/dir/foo");
 *
 * // On a Posix system:
 * fromSysPath("/dir/foo");
 * // -> new URL("file:///dir/foo");
 * ```
 *
 * @param absPath Absolute system-dependent path to convert
 * @return Frozen `file://` URL object.
 */
export function fromSysPath(absPath) {
    return isWindows() ? fromWindowsPath(absPath) : fromPosixPath(absPath);
}
const WINDOWS_PREFIX_REGEX = /^[\\/]{2,}([^\\/]+)(?:$|[\\/]+)/;
const WINDOWS_UNC_REGEX = /^unc(?:$|[\\/]+)([^\\/]+)(?:$|[\\/]+)/i;
/**
 * Converts an absolute Windows path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromWindowsPath("C:\\dir\\foo");
 * // -> new URL(file:///C:/dir/foo");
 * fromWindowsPath("\\\\?\\unc\\server\\Users\\foo");
 * // -> new URL("file://server/Users/foo");
 * ```
 *
 * @param absPath Absolute Windows path to convert
 * @return Frozen `file://` URL object.
 */
export function fromWindowsPath(absPath) {
    const prefixMatch = WINDOWS_PREFIX_REGEX.exec(absPath);
    if (prefixMatch === null) {
        // Short device path
        return formatFileUrl(`/${toForwardSlashes(absPath)}`);
    }
    const prefix = prefixMatch[1];
    const tail = absPath.substring(prefixMatch[0].length);
    if (prefix !== "?") {
        // Short server path
        const result = new url.URL("file:///");
        result.host = prefix;
        result.pathname = encodeURI(`/${toForwardSlashes(tail)}`);
        freezeUrl(result);
        return result;
    }
    // Long path
    const uncMatch = WINDOWS_UNC_REGEX.exec(tail);
    if (uncMatch === null) {
        // Long device path
        return formatFileUrl(`/${toForwardSlashes(tail)}`);
    }
    else {
        // Long server path
        const host = uncMatch[1];
        const serverPath = tail.substring(uncMatch[0].length);
        const result = new url.URL("file:///");
        result.host = host;
        result.pathname = encodeURI(`/${toForwardSlashes(serverPath)}`);
        freezeUrl(result);
        return result;
    }
}
/**
 * Converts an absolute Posix path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromPosixPath("/dir/foo");
 * // -> new URL(file:///dir/foo");
 * ```
 *
 * @param absPath Absolute Posix path to convert
 * @return Frozen `file://` URL object.
 */
export function fromPosixPath(absPath) {
    return formatFileUrl(absPath);
}
/**
 * Replaces all the backward slashes by forward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toForwardSlashes(str) {
    return str.replace(/\\/g, "/");
}
/**
 * Replaces all the forward slashes by backward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toBackwardSlashes(str) {
    return str.replace(/\//g, "\\");
}
/**
 * Creates a frozen `file://` URL using the supplied `pathname`.
 *
 * @param pathname Pathname for the URL object.
 * @return Frozen `file://` URL object.
 * @internal
 */
function formatFileUrl(pathname) {
    const result = new url.URL("file:///");
    result.pathname = encodeURI(pathname);
    freezeUrl(result);
    return result;
}
/**
 * Freezes a URL object.
 *
 * @param writableUrl URL object to freeze.
 * @internal
 */
function freezeUrl(writableUrl) {
    Object.freeze(writableUrl.searchParams);
    Object.freeze(writableUrl);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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ZTtJQUMzQyxPQUFPLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGdCQUFnQixDQUFDLEdBQVc7SUFDbkMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGlCQUFpQixDQUFDLEdBQVc7SUFDcEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxhQUFhLENBQUMsUUFBZ0I7SUFDckMsTUFBTSxNQUFNLEdBQVksSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLFNBQVMsQ0FBQyxXQUFvQjtJQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN4QyxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdCLENBQUMiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZnVyaVxuICovXG5cbmltcG9ydCBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IGlzV2luZG93cyBmcm9tIFwiaXMtd2luZG93c1wiO1xuaW1wb3J0IHVybCBmcm9tIFwidXJsXCI7XG5cbi8qKlxuICogQSBgVVJMYCBpbnN0YW5jZSBvciB2YWxpZCBVUkwgc3RyaW5nLlxuICovXG5leHBvcnQgdHlwZSBVcmxMaWtlID0gdXJsLlVSTCB8IHN0cmluZztcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBpbnB1dCB0byBhIGZyb3plbiBgVVJMYCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgVVJMIHN0cmluZyBvciBpbnN0YW5jZSB0byBub3JtYWxpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0Z1cmkoaW5wdXQ6IFVybExpa2UpOiB1cmwuVVJMIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHdyaXRhYmxlOiB1cmwuVVJMID0gbmV3IHVybC5VUkwoaW5wdXQpO1xuICAgIGZyZWV6ZVVybCh3cml0YWJsZSk7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9IGVsc2UgaWYgKCFPYmplY3QuaXNGcm96ZW4oaW5wdXQpKSB7XG4gICAgY29uc3Qgd3JpdGFibGU6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChpbnB1dC50b1N0cmluZygpKTtcbiAgICBmcmVlemVVcmwod3JpdGFibGUpO1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBpbnB1dCB0byBhIHdyaXRhYmxlIGBVUkxgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBVUkwgc3RyaW5nIG9yIGluc3RhbmNlIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzV3JpdGFibGVVcmwoaW5wdXQ6IFVybExpa2UpOiB1cmwuVVJMIHtcbiAgcmV0dXJuIG5ldyB1cmwuVVJMKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IGlucHV0IDogaW5wdXQudG9TdHJpbmcoKSk7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgcHJvdmlkZWQgY29tcG9uZW50cyB0byB0aGUgcGF0aG5hbWUgb2YgYGJhc2VgLlxuICpcbiAqIEl0IGRvZXMgbm90IG11dGF0ZSB0aGUgaW5wdXRzLlxuICogSWYgY29tcG9uZW50IGxpc3QgaXMgbm9uLWVtcHR5LCB0aGUgYGhhc2hgIGFuZCBgc2VhcmNoYCBhcmUgc2V0IHRvIHRoZVxuICogZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBiYXNlIEJhc2UgVVJMLlxuICogQHBhcmFtIGNvbXBvbmVudHMgUGF0aCBjb21wb25lbnRzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIEpvaW5lZCBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luKGJhc2U6IFVybExpa2UsIGNvbXBvbmVudHM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPik6IHVybC5VUkwge1xuICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYXNGdXJpKGJhc2UpO1xuICB9XG4gIGNvbnN0IHdyaXRhYmxlOiB1cmwuVVJMID0gYXNXcml0YWJsZVVybChiYXNlKTtcbiAgY29uc3Qgb2xkUGF0aG5hbWU6IHN0cmluZyA9IHdyaXRhYmxlLnBhdGhuYW1lO1xuICBjb25zdCB0YWlsOiBzdHJpbmcgPSBjb21wb25lbnRzXG4gICAgLm1hcChlbmNvZGVVUklDb21wb25lbnQpXG4gICAgLmpvaW4oXCIvXCIpO1xuICB3cml0YWJsZS5oYXNoID0gXCJcIjtcbiAgd3JpdGFibGUuc2VhcmNoID0gXCJcIjtcbiAgY29uc3Qgc2VwYXJhdG9yOiBzdHJpbmcgPSBvbGRQYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyBcIlwiIDogXCIvXCI7XG4gIHdyaXRhYmxlLnBhdGhuYW1lID0gYCR7b2xkUGF0aG5hbWV9JHtzZXBhcmF0b3J9JHt0YWlsfWA7XG4gIGZyZWV6ZVVybCh3cml0YWJsZSk7XG4gIHJldHVybiB3cml0YWJsZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgVVJMLlxuICpcbiAqIElmIGBpbnB1dGAgaXMgdGhlIHJvb3QsIGl0IHJldHVybnMgaXRzZWxmIChzYXR1cmF0aW9uKS5cbiAqIElmIGBpbnB1dGAgaGFzIGEgdHJhaWxpbmcgc2VwYXJhdG9yLCBpdCBpcyBmaXJzdCByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBJbnB1dCBVUkwuXG4gKiBAcmV0dXJucyBQYXJlbnQgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50KGlucHV0OiBVcmxMaWtlKTogdXJsLlVSTCB7XG4gIGNvbnN0IHdyaXRhYmxlOiB1cmwuVVJMID0gYXNXcml0YWJsZVVybChpbnB1dCk7XG4gIGNvbnN0IG9sZFBhdGhuYW1lOiBzdHJpbmcgPSB3cml0YWJsZS5wYXRobmFtZTtcbiAgY29uc3QgY29tcG9uZW50czogc3RyaW5nW10gPSBvbGRQYXRobmFtZS5zcGxpdChcIi9cIik7XG4gIGlmIChjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPT09IFwiXCIpIHtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yXG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuICBjb21wb25lbnRzLnBvcCgpO1xuICB3cml0YWJsZS5wYXRobmFtZSA9IGNvbXBvbmVudHMuam9pbihcIi9cIik7XG4gIGZyZWV6ZVVybCh3cml0YWJsZSk7XG4gIHJldHVybiB3cml0YWJsZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEZpbGUgVVJJIHRvIGEgc3lzdGVtLWRlcGVuZGVudCBwYXRoLlxuICpcbiAqIFVzZSBgdG9Qb3NpeFBhdGhgLCBgdG9XaW5kb3dzU2hvcnRQYXRoYCBvciBgdG9XaW5kb3dzTG9uZ1BhdGhgIGlmIHlvdVxuICogd2FudCBzeXN0ZW0taW5kZXBlbmRlbnQgcmVzdWx0cy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIE9uIGEgV2luZG93cyBzeXN0ZW06XG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIkM6XFxcXGRpclxcXFxmb29cIjtcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiLCB0cnVlKTtcbiAqIC8vIC0+IFwiXFxcXFxcXFw/XFxcXEM6XFxcXGRpclxcXFxmb29cIjtcbiAqXG4gKiAvLyBPbiBhIFBvc2l4IHN5c3RlbTpcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly8vZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IFwiL2Rpci9mb29cIjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmdXJpIEZpbGUgVVJJIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gd2luZG93c0xvbmdQYXRoIFVzZSBsb25nIHBhdGhzIG9uIFdpbmRvd3MuIChkZWZhdWx0OiBgZmFsc2VgKVxuICogQHJldHVybiBTeXN0ZW0tZGVwZW5kZW50IHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N5c1BhdGgoZnVyaTogc3RyaW5nLCB3aW5kb3dzTG9uZ1BhdGg6IGJvb2xlYW4gPSBmYWxzZSk6IHN0cmluZyB7XG4gIGlmIChpc1dpbmRvd3MoKSkge1xuICAgIHJldHVybiB3aW5kb3dzTG9uZ1BhdGggPyB0b1dpbmRvd3NMb25nUGF0aChmdXJpKSA6IHRvV2luZG93c1Nob3J0UGF0aChmdXJpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9Qb3NpeFBhdGgoZnVyaSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEZpbGUgVVJJIHRvIGEgV2luZG93cyBzaG9ydCBwYXRoLlxuICpcbiAqIFRoZSByZXN1bHQgaXMgZWl0aGVyIGEgc2hvcnQgZGV2aWNlIHBhdGggb3IgYSBzaG9ydCBVTkMgc2VydmVyIHBhdGguXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIkM6XFxcXGRpclxcXFxmb29cIjtcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly9zZXJ2ZXIvVXNlcnMvZm9vXCIpO1xuICogLy8gLT4gXCJcXFxcXFxcXHNlcnZlclxcXFxVc2Vyc1xcXFxmb29cIjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmdXJpIEZpbGUgVVJJIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIFdpbmRvd3Mgc2hvcnQgcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvV2luZG93c1Nob3J0UGF0aChmdXJpOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB1cmxPYmo6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChmdXJpKTtcbiAgaWYgKHVybE9iai5ob3N0ID09PSBcIlwiKSB7XG4gICAgLy8gTG9jYWwgZHJpdmUgcGF0aFxuICAgIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSB1cmxPYmoucGF0aG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIGNvbnN0IGZvcndhcmQ6IHN0cmluZyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKTtcbiAgICByZXR1cm4gdG9CYWNrd2FyZFNsYXNoZXMoZm9yd2FyZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2VydmVyIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gbmV3IHVybC5VUkwoZnVyaSkucGF0aG5hbWU7XG4gICAgY29uc3QgZm9yd2FyZDogc3RyaW5nID0gcGF0aG5hbWUuc3BsaXQoXCIvXCIpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICAgIGNvbnN0IGJhY2t3YXJkOiBzdHJpbmcgPSB0b0JhY2t3YXJkU2xhc2hlcyhmb3J3YXJkKTtcbiAgICByZXR1cm4gYFxcXFxcXFxcJHt1cmxPYmouaG9zdH0ke2JhY2t3YXJkfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEZpbGUgVVJJIHRvIGEgV2luZG93cyBsb25nIHBhdGguXG4gKlxuICogVGhlIHJlc3VsdCBpcyBlaXRoZXIgYSBsb25nIGRldmljZSBwYXRoIG9yIGEgbG9uZyBVTkMgc2VydmVyIHBhdGguXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB0b1dpbmRvd3NQYXRoKFwiZmlsZTovLy9DOi9kaXIvZm9vXCIpO1xuICogLy8gLT4gXCJcXFxcXFxcXD9cXFxcQzpcXFxcZGlyXFxcXGZvb1wiO1xuICogdG9XaW5kb3dzUGF0aChcImZpbGU6Ly9zZXJ2ZXIvVXNlcnMvZm9vXCIpO1xuICogLy8gLT4gXCJcXFxcXFxcXD9cXFxcdW5jXFxcXHNlcnZlclxcXFxVc2Vyc1xcXFxmb29cIjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmdXJpIEZpbGUgVVJJIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIFdpbmRvd3MgbG9uZyBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9XaW5kb3dzTG9uZ1BhdGgoZnVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsT2JqOiB1cmwuVVJMID0gbmV3IHVybC5VUkwoZnVyaSk7XG4gIGlmICh1cmxPYmouaG9zdCA9PT0gXCJcIikge1xuICAgIC8vIExvY2FsIGRyaXZlIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lLnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBmb3J3YXJkOiBzdHJpbmcgPSBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG4gICAgY29uc3QgYmFja3dhcmQ6IHN0cmluZyA9IHRvQmFja3dhcmRTbGFzaGVzKGZvcndhcmQpO1xuICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXCR7YmFja3dhcmR9YDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTZXJ2ZXIgcGF0aFxuICAgIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSBuZXcgdXJsLlVSTChmdXJpKS5wYXRobmFtZTtcbiAgICBjb25zdCBmb3J3YXJkOiBzdHJpbmcgPSBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG4gICAgY29uc3QgYmFja3dhcmQ6IHN0cmluZyA9IHRvQmFja3dhcmRTbGFzaGVzKGZvcndhcmQpO1xuICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXHVuY1xcXFwke3VybE9iai5ob3N0fSR7YmFja3dhcmR9YDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgRmlsZSBVUkkgdG8gYSBQb3NpeCBwYXRoLlxuICpcbiAqIFJlcXVpcmVzIHRoZSBob3N0IHRvIGJlIGVpdGhlciBhbiBlbXB0eSBzdHJpbmcgb3IgYFwibG9jYWxob3N0XCJgLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdG9Qb3NpeFBhdGgoXCJmaWxlOi8vL2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIi9kaXIvZm9vXCI7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZnVyaSBGaWxlIFVSSSB0byBjb252ZXJ0LlxuICogQHJldHVybiBQb3NpeCBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qb3NpeFBhdGgoZnVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsT2JqOiB1cmwuVVJMID0gbmV3IHVybC5VUkwoZnVyaSk7XG4gIGlmICh1cmxPYmouaG9zdCAhPT0gXCJcIiAmJiB1cmxPYmouaG9zdCAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgIGFzc2VydC5mYWlsKGBFeHBlY3RlZCBcXGBob3N0XFxgIHRvIGJlIFwiXCIgb3IgXCJsb2NhbGhvc3RcIjogJHtmdXJpfWApO1xuICB9XG4gIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSB1cmxPYmoucGF0aG5hbWU7XG4gIHJldHVybiBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYWJzb2x1dGUgc3lzdGVtLWRlcGVuZGVudCBwYXRoIHRvIGEgZnJvemVuIFVSTCBvYmplY3QuXG4gKlxuICogVXNlIGBmcm9tUG9zaXhQYXRoYCBvciBgZnJvbVdpbmRvd3NQYXRoYCBpZiB5b3Ugd2FudCBzeXN0ZW0taW5kZXBlbmRlbnRcbiAqIHJlc3VsdHMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBPbiBhIFdpbmRvd3Mgc3lzdGVtOlxuICogZnJvbVN5c1BhdGgoXCJDOlxcXFxkaXJcXFxcZm9vXCIpO1xuICogLy8gLT4gbmV3IFVSTChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqXG4gKiAvLyBPbiBhIFBvc2l4IHN5c3RlbTpcbiAqIGZyb21TeXNQYXRoKFwiL2Rpci9mb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKFwiZmlsZTovLy9kaXIvZm9vXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFic1BhdGggQWJzb2x1dGUgc3lzdGVtLWRlcGVuZGVudCBwYXRoIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4gRnJvemVuIGBmaWxlOi8vYCBVUkwgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN5c1BhdGgoYWJzUGF0aDogc3RyaW5nKTogdXJsLlVSTCB7XG4gIHJldHVybiBpc1dpbmRvd3MoKSA/IGZyb21XaW5kb3dzUGF0aChhYnNQYXRoKSA6IGZyb21Qb3NpeFBhdGgoYWJzUGF0aCk7XG59XG5cbmNvbnN0IFdJTkRPV1NfUFJFRklYX1JFR0VYOiBSZWdFeHAgPSAvXltcXFxcL117Mix9KFteXFxcXC9dKykoPzokfFtcXFxcL10rKS87XG5jb25zdCBXSU5ET1dTX1VOQ19SRUdFWDogUmVnRXhwID0gL151bmMoPzokfFtcXFxcL10rKShbXlxcXFwvXSspKD86JHxbXFxcXC9dKykvaTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBXaW5kb3dzIHBhdGggdG8gYSBmcm96ZW4gVVJMIG9iamVjdC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIGZyb21XaW5kb3dzUGF0aChcIkM6XFxcXGRpclxcXFxmb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKGZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqIGZyb21XaW5kb3dzUGF0aChcIlxcXFxcXFxcP1xcXFx1bmNcXFxcc2VydmVyXFxcXFVzZXJzXFxcXGZvb1wiKTtcbiAqIC8vIC0+IG5ldyBVUkwoXCJmaWxlOi8vc2VydmVyL1VzZXJzL2Zvb1wiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYnNQYXRoIEFic29sdXRlIFdpbmRvd3MgcGF0aCB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21XaW5kb3dzUGF0aChhYnNQYXRoOiBzdHJpbmcpOiB1cmwuVVJMIHtcbiAgY29uc3QgcHJlZml4TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSBXSU5ET1dTX1BSRUZJWF9SRUdFWC5leGVjKGFic1BhdGgpO1xuICBpZiAocHJlZml4TWF0Y2ggPT09IG51bGwpIHtcbiAgICAvLyBTaG9ydCBkZXZpY2UgcGF0aFxuICAgIHJldHVybiBmb3JtYXRGaWxlVXJsKGAvJHt0b0ZvcndhcmRTbGFzaGVzKGFic1BhdGgpfWApO1xuICB9XG4gIGNvbnN0IHByZWZpeDogc3RyaW5nID0gcHJlZml4TWF0Y2hbMV07XG4gIGNvbnN0IHRhaWw6IHN0cmluZyA9IGFic1BhdGguc3Vic3RyaW5nKHByZWZpeE1hdGNoWzBdLmxlbmd0aCk7XG4gIGlmIChwcmVmaXggIT09IFwiP1wiKSB7XG4gICAgLy8gU2hvcnQgc2VydmVyIHBhdGhcbiAgICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICAgIHJlc3VsdC5ob3N0ID0gcHJlZml4O1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IGVuY29kZVVSSShgLyR7dG9Gb3J3YXJkU2xhc2hlcyh0YWlsKX1gKTtcbiAgICBmcmVlemVVcmwocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIExvbmcgcGF0aFxuICBjb25zdCB1bmNNYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IFdJTkRPV1NfVU5DX1JFR0VYLmV4ZWModGFpbCk7XG4gIGlmICh1bmNNYXRjaCA9PT0gbnVsbCkge1xuICAgIC8vIExvbmcgZGV2aWNlIHBhdGhcbiAgICByZXR1cm4gZm9ybWF0RmlsZVVybChgLyR7dG9Gb3J3YXJkU2xhc2hlcyh0YWlsKX1gKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMb25nIHNlcnZlciBwYXRoXG4gICAgY29uc3QgaG9zdDogc3RyaW5nID0gdW5jTWF0Y2hbMV07XG4gICAgY29uc3Qgc2VydmVyUGF0aDogc3RyaW5nID0gdGFpbC5zdWJzdHJpbmcodW5jTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICAgIHJlc3VsdC5ob3N0ID0gaG9zdDtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBlbmNvZGVVUkkoYC8ke3RvRm9yd2FyZFNsYXNoZXMoc2VydmVyUGF0aCl9YCk7XG4gICAgZnJlZXplVXJsKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFic29sdXRlIFBvc2l4IHBhdGggdG8gYSBmcm96ZW4gVVJMIG9iamVjdC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIGZyb21Qb3NpeFBhdGgoXCIvZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IG5ldyBVUkwoZmlsZTovLy9kaXIvZm9vXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFic1BhdGggQWJzb2x1dGUgUG9zaXggcGF0aCB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Qb3NpeFBhdGgoYWJzUGF0aDogc3RyaW5nKTogdXJsLlVSTCB7XG4gIHJldHVybiBmb3JtYXRGaWxlVXJsKGFic1BhdGgpO1xufVxuXG4vKipcbiAqIFJlcGxhY2VzIGFsbCB0aGUgYmFja3dhcmQgc2xhc2hlcyBieSBmb3J3YXJkIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmcuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9Gb3J3YXJkU2xhc2hlcyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgYWxsIHRoZSBmb3J3YXJkIHNsYXNoZXMgYnkgYmFja3dhcmQgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0b0JhY2t3YXJkU2xhc2hlcyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFwvL2csIFwiXFxcXFwiKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJvemVuIGBmaWxlOi8vYCBVUkwgdXNpbmcgdGhlIHN1cHBsaWVkIGBwYXRobmFtZWAuXG4gKlxuICogQHBhcmFtIHBhdGhuYW1lIFBhdGhuYW1lIGZvciB0aGUgVVJMIG9iamVjdC5cbiAqIEByZXR1cm4gRnJvemVuIGBmaWxlOi8vYCBVUkwgb2JqZWN0LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEZpbGVVcmwocGF0aG5hbWU6IHN0cmluZyk6IHVybC5VUkwge1xuICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICByZXN1bHQucGF0aG5hbWUgPSBlbmNvZGVVUkkocGF0aG5hbWUpO1xuICBmcmVlemVVcmwocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGcmVlemVzIGEgVVJMIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gd3JpdGFibGVVcmwgVVJMIG9iamVjdCB0byBmcmVlemUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZnJlZXplVXJsKHdyaXRhYmxlVXJsOiB1cmwuVVJMKTogdm9pZCB7XG4gIE9iamVjdC5mcmVlemUod3JpdGFibGVVcmwuc2VhcmNoUGFyYW1zKTtcbiAgT2JqZWN0LmZyZWV6ZSh3cml0YWJsZVVybCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9
